8일차 

메소드 시그니처 = 메소드 선언부
시그니처가 다르다면 메소드 명은 같아도 됨 < 자바만의 특징

클래스 

클래스 = 객체 생성의 설계도
인스턴스 = 클래스로부터 만들어진 객체 
객체 = 자신의 속성을 가지고 있으면서 식별 가능한 것

클래스 명명규칙
모든 단어의 첫글자 대문자
하나 이상의 문자
첫글자 숫자 X
예약어 사용 불가능

하나의 파일에 class를 여러개 쓸 수도 있음 = 여러개에 class 파일 생성, public은 하나만

public = 파일 이름과 동일한 이름의 클래스 선언에만 붙일 수 있음
new = 객체 생성 연산자, 생성자 호출 연산자

메인메소드가 없으면 홀로 실행될 수 없음 = 라이브러리용
실행 클래스에서 설계도를 가져와 객체를 생성하여 활용

Class 파일은 컴파일 후 생성되니 꼭 저장을 하자

API  "Application Programming Interface" 의미 알아두기
소프트웨어 응용 프로그램을 개발하고 통합하기 위한 도구나 규약을 제공하는 인터페이스
내부 작동 원리를 몰라도 API를 통해 쉽게 접근할 수있음

클래스 구성 = 필드, 생성자, 메소드

필드 = 객체의 속성이 저장되는 곳, 객체가 소멸할 때 까지 존재함, 변수와는 구분됨

메소드 = 객체의 동작을 설명하는 중괄호 블럭

생성자 = new 연산자로 호출되는 중괄호 블록으로 클래스 이름과 같음 
객체 생성시 필드와 메소드를 호출하는 등 초기화 과정을 담당
모든 클래스에 하나 이상 존재함, 호출될 이름과 같음, 리턴타입이 없음

public + class명 ( 매개변수 ) { 
실행문 블록 
} 

생성자를 생략시 컴파일러가 기본생성자를 만들어줌

객체지향 프로그래밍 = 객체를 만들고 객체를 조립해 프로그램을 완성하는 기법

객체간의 상호작용 수단 = 메소드 호출 => 매개값과 리턴값을 통해 데이터를 주고받음 

리턴받을 변수 = 객체.메소드(매개값);

매개값 = 메소드를 실행하기 위해 필요한 데이터 또는 변수

리턴값 = 메소드를 실행한 결과 값을호출했던 곳으로 돌려주는 값

설계에는 원칙이 없다


객체 간의 관계는 크게 상속관계, 사용관계, 집합관계로 정의할 수 있다
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
필드 

필드 선언 = 생성자와 메소드 블록을 제외한 클래스 중괄호 블록 어디서든 가능함
로컬변수 = 생성자와 메소드 블록 내부에서 선언된 것

양식 = 타입 + 필드(= 초기값); << 변수 선언과 같음
초기값은 생략 가능하며 생략시 기본값 

필드사용 = 필드값을 읽고 변경하는 작업

선언된 클래스 내부 = 바로 사용 가능
선언된 클래스 외부 = 객체 생성 후 참조 변수를 통해 사용 가능 
>> 	acc = new Account(id, pw);

필드는 객체에 소속된 데이터이므로 객체가 존재한 이후에 필드가 존재함
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
생성자

생성자 = new 연산자에게 호출되어 객체의 초기화를 담당, 생성과 초기화가 동시에 일어난다

new 연산자로 호출되는 중괄호 블록으로 클래스 이름과 같음 
객체 생성시 필드와 메소드를 호출하는 등 초기화 과정을 담당, 생성가 동시에 초기화가 일어남
모든 클래스에 하나 이상 존재함, 호출될 이름과 같음, 리턴타입이 없음
객체를 만들려면 무조건 생성자를 실행해야함
실행된 후 heap 영역에 객체가 생성되고 클래스 변수에 번지가 리턴됨

기본생성자 = 생성자 선언을 안하면 컴파일러가 기본적으로 추가해주는 생성자 
선언된 클래스의 접근제한자를 따라감

생성자를 선언하는 목적 = 다양한 방식으로 초기화 하기 위함

생성자가 직접 선언된 경우 선언된 생성자중에서만 호출할 수 있음

선언양식
클래스명(매개변수 선언){
실행문(필드 초기화, 실행 메소드)
}

생성자 선언의 매개변수는 호출될 때 외부에서 입력된 매개값을 생성자 블록 내부로 전달하는 역할

객체 생성시 필드 초기화 방법
1.필드를 선언할 때 초기값을 주는 방법
String name = "승탁"

2.생성자에서 초기값을 주는 방법 
public Student(String name){ << 클래스의 필드 부분
this.name = name
}
Student student = new Student("승탁"); << 생성자의 매개변수 String name에 전달되는 값

이때 가독성을 위해 매개변수와 필드의 이름은 같게 설정하고 
this.name = name 과 같은 방식으로 필드와 매개변수를 구분해준다

생성자 오버로딩 = 생성자 다양화 << 이용에 편리하도록 
최초에 생산자에서 변수명만 바뀌는 것이 아닌 매개값를 달리하는 생성자를 여러개 선언하는 것

생성자 선택은 new 연산자로 객체 생성시 피연산자의 매개값을 통해 할 수 있다

new 연산자가 클래스로부터 객체를 생성할때 호출되어 초기화를 담당함

CTRL + ALT + S = 자주쓰는 양식 생성

Generate Constructor using Fields:
클래스의 필드를 기반으로 생성자를 생성, 반영할 필드를 선택할 수 있음

Generate toString():
객체의 문자열 표현을 생성하는 toString() 메서드 생성
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
메소드
메소드 명명 
소문자, 동작을 설명하는 이름

필드설계 -> 메소드 설계