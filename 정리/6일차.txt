JSP 공부 - 김영한
JSP - 이클립스에서 구동하는 웹서버 , new - 다이나믹 웹 서버
JSP설치 = 톰캣
preference = server = runtime enviroments = add = apache = tomcat v9.0 = browse = 압축을 푼 경로에서 tomcat 폴더 선택 = 확인
preference = general = workspace = utf8
preference = web = jsp files, HTML, CSS = ISO 10646/Unicode(UTF-8
src /main/ webapp = index.jsp 생성
실행시 로컬호스트 선택 
 
JSP 
<% %> (Scriptlet태그) = Java 코드를 JSP 페이지에 삽입할 수 있음
<%! %> = 메소드 또는 클래스 등을 선언할 때 
<%@ %> = 페이지 속성을 지정하는 데 사용됨  <%@로 시작해서 %>로 끝남




리턴 = 메인에서 리턴받을 변수 설정
리턴하는 메소드 = 선언부에 타입 설정, 메소드의 끝에 리턴 설정

정수선택 = switch문이 직관적이고 좋음
맨 앞숫자만 남기기 = 나누기 10, 100 , 1000... 로 뒷숫자 날리기
case문으로 대소문자 상관없게 하는방법
case "b":
case "B":
중첩된 반복문을 한번에 빠져나가는 방법 = Label
로그인 여부 
회원가입 여부 

메소드는 다른 메소드에서 호출할 때 

리턴값이 있는 메소드 
메소드 선언부에 설정한 리턴 타입과 일치하는 값을 리턴할 수 있음
해당 타입의 변수 또는 리터럴을 리턴 가능
하나의 값만 리턴할 수 있으며 두 개 이상을 리턴하고 싶다면
따로 여러 값을 묶어놓은 객체를 생성해야한다


winmerge = 같은 베이스로 만든 다른 버전의 코드를 합치고 비교하기 좋은 도구, 버전관리에 용이함

scanner를 열었으면 scanner.close(); 를 해줄 것

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
메인이 실행 시작점 메인 메서드의 위치는 상관 없음 
메인 메서드에서 다른 메서드를 호출하는 순간 메모리에 배정

파싱(Parsing) = 구문 분석
파싱은 데이터를 이해하고 활용할 수 있는 형태로 변환하는 중요한 단계로 필요에 따라 다양한 파싱 기술과 도구가 사용됨
특정한 형식을 가진 데이터나 문장을 해석하고 원하는 정보를 추출하는 과정  
주로 텍스트나 데이터를 프로그램이나 컴퓨터가 이해할 수 있는 구조로 변환하는 작업을 의미함

코드는 위에서 아래로 읽히지만, 메모리 할당 및 프로그램의 실행 절차에는 차이가 있음
보통 컴파일러나 인터프리터는 프로그램을 한 번에 읽고 처리하지 않고, 일반적으로는 아래와 같은 과정을 거침

1.코드의 읽기 및 파싱(Parsing)
프로그램의 구조를 이해하며 이 과정에서 메서드 선언이나 기타 구조가 파악됨

2.메모리 할당 및 실행 흐름 파악
코드 파싱 이후  메모리를 할당하고 프로그램의 실행 흐름을 파악함 이때 메인 메서드의 위치를 찾아서 실행을 시작합니다.

3.메서드 호출:
메인 메서드 실행 중 다른 메서드가 호출되면, 해당 메서드의 위치로 이동하여 실행 << 선언 위치는 이미 1번에서 파악
호출된 메서드가 다시 종료되면, 호출했던 지점으로 돌아와서 계속 진행

요약하면 메인 메서드를 찾아 실행하기 전 코드를 파악한 이후
실행 흐름에 따라 메소서가 호출되고 미리 파악해놓은 메소드 공간에
메모리를 할당하면서 호출된 메서드가 실행된다
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

파싱의 종류 
1.언어 파싱
-컴파일러가 소스 코드를 읽어들여 프로그램이 이해할 수 있는 중간 표현으로 변환하는 과정
토큰화(tokenization)와 문법 규칙을 기반으로 하며, 파서(parser)가 이러한 작업을 수행합니다.

원시코드 = 소스코드 = 고급언어 = 프로그래밍 언어 = 사람이 이해하기 편한 언어
기계어 = 저급언어 = 컴퓨터가 이해하기 편한 언어 = 컴퓨터 내부에서 바로 처리 가능함

*저급언어 = 어셈블리어 + 기계어
컴파일러 = 고급언어 > 중간언어, 중간언어 > 목적언어
링커 = 목적언어 > 기계어
기계어(CPU언어)
CPU를 만들 때 해당 CPU에서 사용하는 명령어 집합일 뿐 특정한 언어가 아님
CPU 제조사마다 다른 형태의 기계어를 사용함 같은 동작을 하는 명령어지만 완전히 다른 0과 1의 나열이 될 수 있음

어셈블리어 
기계어와 일대일대응 되는 니모닉 기호(mnemonic symbol)를 이용한 코드
기계어보다는 인간이 이해하기 쉽지만 저급언어에 포함된다 
컴퓨터 하드웨어의 세부 사항에 직접 접근할 수 있지만, 동시에 이해하기 어려우며 이식성이 낮음
주로 하드웨어 제어, 특히 성능이 중요한 시스템 프로그래밍이나 임베디드 시스템에서 사용됨

중간표현
중간 표현은 컴파일러또는 가상머신에서 소스 코드를 목적 코드로 변환할 때 내부적으로 사용하는 데이터 또는 코드 구조
컴파일러, 인터프리터, 혹은 다른 소프트웨어 도구에서 소스 코드를 다루는 중간 단계에서의 내부적인 표현을 의미
-컴파일러나 가상머신에서 사용되는 내부 표현(데이터 구조 또는 코드)을 뜻하는 포괄적인 용어로,
소스 코드를 목적 코드로 변환하기 위해 사용되는 중간 형태의 추상적인 표현을 의미하며 다양한 형태가 있음

중간코드
사람이 프로그래밍한 프로그램과 CPU에서 사용할 수 있는 기계어의 중간 상태의 코드를 뜻한다. 프로그램을 기계어로 번역하고 최적화하기 위해서는 먼저 중간 코드로 번역하고, 중간 코드를 최적화한 뒤에 기계어로 번역하게 된다.

바이트 코드(자바에서 사용되는 중간코드의 한 형태이며 목적코드에 속한다)
고급언어로 작성된 소스코드를 가상 머신이 이해할 수 있는 중간 코드로 컴파일한 것 이진코드의 형태를 띤다

목적코드(=목적파일)
특정 목적을 달성하기 위해 소스코드가 컴파일러나 어셈블러 등의 도구에 의해 번역되어 생성된 최종적인 이진형태의 코드
컴퓨터가 이해할 수있는 바이너리 코드(이진 코드)형태이지만 완전한 기계어라고 할 수는없음
목적코드가 링커에 의해 실행파일로 변환되는 과정을 거쳐야 기계어라고 간주할 수 있음

바이너리 코드 
0과 1로 이루어진 이진 형태의 코드를 의미하며 컴퓨터가 직접 이해하고 처리할 수 있음
하지만 모든 바이너리 코드가 기계어인 것은 아니며 그중 컴퓨터가 이해할 수있는 부분이 기계어이다


ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
이처럼 실행 흐름이 전환되는 것은 메서드 호출과 관련이 있으며, 이 과정은 호출 스택(Call Stack)이라는 메모리 구조를 통해 관리됩니다. 호출 스택은 현재 실행 중인 메서드들의 호출 정보를 저장하고, 메서드가 호출되면 스택에 새로운 프레임이 추가되고, 메서드가 종료되면 해당 프레임이 제거되면서 실행 흐름이 이동합니다.


메서드 호출 절차
메서드 호출이 발생하면 컴파일러는 해당 메서드의 위치로 이동하지 않고
프로그램의 실행 흐름을 해당 메서드로 전환하여 해당 이 프로세스는 실행 시간(runtime)에 이루어집니다.

일반적으로 메서드 호출은 다음과 같은 과정을 거칩니다:

현재 실행 중인 메서드의 상태 저장: 현재 실행 중인 메서드의 로컬 변수, 반환 주소 등의 상태는 스택 프레임에 저장됩니다.

호출된 메서드로 이동: 호출된 메서드로 실행 흐름이 전환됩니다. 이때 호출된 메서드의 코드가 실행되기 시작합니다.

호출된 메서드의 로컬 스코프에서 작업: 호출된 메서드 내에서 필요한 작업이 수행됩니다. 이 과정에서 메서드 내에서 다른 메서드가 호출될 수 있습니다.

호출된 메서드의 종료: 호출된 메서드가 종료되면, 반환 값과 함께 호출된 메서드의 스택 프레임이 제거됩니다.

이전 메서드로 복귀: 이전에 저장한 반환 주소를 사용하여 이전 메서드로 실행 흐름이 복귀됩니다. 이때 이전 메서드의 상태를 복원하면서 이전 메서드의 실행이 계속됩니다.

이러한 메서드 호출과정은 실행 중에 동적으로 이루어지며, 컴파일러가 이를 적절히 관리하여 프로그램이 올바르게 동작하도록 합니다.

메서드 호출과정에서 컴파일러와 런타임 시스템

컴파일러 역할:

컴파일러는 소스 코드를 기계어 또는 중간 언어로 변환하는 역할을 합니다. 컴파일러는 소스 코드를 읽어들여 문법적으로 올바르게 작성되었는지를 검사하고, 그것을 기계어 코드로 변환합니다. 이때 메서드의 위치와 같은 절대적인 메모리 주소는 아직 알지 못합니다. 대신, 컴파일러는 메서드가 호출되는 방법, 매개변수 전달 방법, 반환 값 처리 방법 등을 명세하는 명령을 생성합니다.

실행 시간(runtime)에서의 동작:

프로그램이 실행되면 런타임 시스템이 이 명령들을 해석하고 실행합니다. 메서드 호출이 발생하면, 런타임 시스템은 해당 메서드의 코드가 위치한 주소를 찾아가는 것이 아니라, 호출 스택(Call Stack)에 새로운 프레임을 추가합니다. 이 프레임에는 호출된 메서드의 지역 변수, 매개변수, 반환 주소 등이 저장됩니다.

호출 스택은 메서드가 중첩되어 호출될 때마다 새로운 프레임이 추가되고, 메서드가 종료될 때마다 해당 프레임이 제거됩니다. 이러한 방식으로 호출 스택은 현재 실행 중인 메서드의 상태를 추적하고, 메서드 간의 호출 및 반환 관계를 유지합니다.

따라서, 메서드 호출이 발생하면 실제로는 현재 실행 중인 메서드의 실행이 중단되고 호출된 메서드로 실행 흐름이 전환되는 것이 아니라, 호출 스택을 통해 새로운 메서드의 실행 상태가 추가되고, 그 메서드가 실행되는 것입니다.

이러한 호출 스택의 동작은 함수 호출 및 반환을 효율적으로 관리하며, 재귀 호출과 같은 다양한 프로그래밍 구조를 다룰 수 있도록 합니다.
