김영한 JAVA 입문 강의 
https://www.inflearn.com/course/%EA%B9%80%EC%98%81%ED%95%9C%EC%9D%98-%EC%9E%90%EB%B0%94-%EC%9E%85%EB%AC%B8
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
자바 표준 스펙 = 컴파일러, 실행 라이브러리, 가상머신 
다양한 자바 구현 툴들은 자바 표준 스펙을 준수하여 만들어져 호환이 가능하다

변수가 선언되면 RAM메모리 공간이 할당되어 데이터를 저장할 수 있게 된다

컴퓨터 메모리는 여러 시스템이 공동으로 사용하며 값들을 저장한다
따라서 해당 메모리 공간에 이미 다른 시스템이 입력했던 어떠한 값이 남아있을 수있다 
이러한  경우 의도한 값과 다른 값을 불러올 수 있기 때문에 자바는 변수 초기화를 강제하고 있다

컴파일 에러 = 자바 문법에 맞지 않을 때 발생하는 에러

테스트에 방해가 되는 경우 에러가 발생한 라인을 주석처리하여 컴파일을 진행할 수 있다
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
변수는 다루는 데이터 종류에 따라 다양한 타입(형식, 형)이 존재하며
자신의 타입에 맞는 값을 사용할 수 있다

정수형
byte = 2^8 = ±2^7
short = 2^16 = ±2^15
int = 2^32 = ±2^31 = 정수 타입 기본형
long = 2^64 = ±2^64

실수형
float = 10.0f = 뒤에 꼭 f를 붙여야함
double = 10.0 = 실수 타입 기본형
boolean = 불리언 = True / False

char = 문자 하나 = 'a' 작은 따옴표
String = 문자열 = "aa" 쌍따옴표, 문자 길이에 따라 메모리 사용량이 동적으로 달라짐

리터럴(literal) = 코드에서 개발자가 직접 적은 고정된 값, 변수와 달리 변하지 않음

실무에서 쓰지 않는 타입
byte short = 표현 길이가 너무 작음
float = 표현 길이와 정밀도가 낮음
char = 문자 하나를 표현할 일이 없고 String으로 대체 가능

자주 사용하는 타입
int, long, double, boolean, String
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
규칙 = 필수, 안하면 오류
관례 = 필수는 아니지만 지켜야 할 것

변수 명명 규칙

규칙 
숫자로 시작 불가능
공백이 들어갈 수 없음
자바의 예약어 사용 불가능
영문자, 숫자, $, _만 사용 가능

관례
낙타표기법 사용 = 첫 단어 소문자(myAccount, orderDetail) = 공백 없어도 구분 쉬움

명명 규칙

패키지는 모두 소문자
상수는 모두 대문자 + 언더바( _ )로 구분
클래스는 모든 단어의 첫 글자 대문자 
나머지는 다 낙타표기법

변수의 이름은 의미와 용도를 명확하게 전달할 수 있어야 한다
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
연산자
계산을 수행하는 기호

연산자의 종류
산술 + - * / %
증감 ++ --
비교 == != > < >= <=
논리 && || !
대입 = += -= *= /= %=
상황 ?

연산자 = 연산기호
피연산자 = 연산 대상

산술연산자 = 수학연산, 0으로 나누면 오류

문자열 + 문자열 = 문자열 붙이기 = 더 큰 문자열이 됨
문자열 + @ = 문자열화 되어버린 후 붙임

연산자 우선순위

1 + 2 * 3 = 7
(1 + 2) * 3 = 9
괄호 > 곱셈 나눗셈 > 덧셈 뺄셈

연산자 우선순위가 복잡해보이거나 조금이라도 애매하면 괄호를 쓰자

그냥 언제나 괄호를 사용하여 가독성을 향상시키자
코드를 좀 더 쓰더라도 명확하고 단순한게 좋다

연산자 우선순위 암기법 = 암기할 필요 없음
필요할 때 검색 + 상식선에서 생각 + 애매하면 괄호

코딩의 핵심은 단순함과 명확함 
코딩은 혼자하는게 아니며 시간이 지나 다시 봤을 때  알아볼 수도 없다


증감 연산자 
1씩 증가하거나 감소함

증감연산자
전위 (++a) : 증감연산이 먼저 수행된 후 나머지 연산이 수행

후위 (a++) : 나머지 연산이 수행된 후 마지막으로 증감연산 수행

a = 1 b = 0
b = a++ << a = 2 b = 1
b = ++a << a = 2 b = 2 


비교연산자 
두값을 비교하는 데 사용
== 동등 (문자열 비교는 .equals() 메서드
!= 불일치
> 크다
< 작다
>= 크거나 같다
<= 작거나 같다

논리연산자
&& || !

대입 연산자
= += -= *= /= %=

삼항연산자	?	:
instanceof 연산자
new, [], . , ()

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
if문 여러개 = 모든 if 문 수행
else if = 하나만 만족하면 나머지 수행 안하고 앞에서 검증한 부분을 다시 검증하지 않음
1~7은 아니다 => 8부터 체크

조건이 서로 관계가 없는 경우 = 독립조건 = if문 두개를 따로 쓰기 = 두번 실행
ex) 할인이 중복으로 적용되어야 할 때

둘중 하나만 실행되어야 하는 경우 = if문 + else if / else = 묶어서 한번만 실행
ex)여러 할인 조건 중 하나만 적용되어야 할 때
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
switch 문 
단순히 값이 같은지만 비교하여 실행되는 조건문
switch(변수){
case x :
실행문
break;

default :
실행문
break;

case = 값이 일치하면 실행되는 실행문
default = 기본적으로 실행되는 실행문
break 문을 설정하지 않으면 모든 case를 실행함

if = 조건식이 훨씬 자유로움
switch = 조건이 제한적이지만 간편하고 직관적임 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
삼항 연산자 = ? :
단순히 참과 거짓에 따라서 특정 값을 구하는 경우 사용 가능

조건 ? 참 표현식  : 거짓 표현식
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
if문이 근본이고 나머지는 다 if문을 조금 더 편리하게 쓰기 위한 옵션
if문으로 다 할 수 있음
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
스코프 존재 이유 
메모리 관리
변수명 재활용 및 코드 복잡성
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
변수 연산자 조건문 반복문을 다루는 능력 = 프로그래밍의 기본기
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
증가하는 i값이 필요할 때는 향상된 for문을 쓸 수 없다
쓸 수는 있지만 억지스럽고 코드가 이상해진다
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
nextInt = 엔터를 치면 10\n 에서 10만 먹고 \n이 남아 제거를 해줘야함